<!-- e3481ab7-5d54-4d8c-9bb7-2f80268e192d 8e56efda-3604-480b-8a33-7a86161b4b8f -->
# 完整可视化系统实现计划

## 目标

根据 `docs/01_visual.md` 的要求，实现完整的性能指标收集和可视化系统，包括：

1. 扩展算法类以收集所有必需指标
2. 重新实现可视化模块以符合文档规范
3. 更新实验脚本以生成所有要求的图表

## 核心文件

- `src/second_shortest_path/algorithms/dijkstra_two_dist.py` - Dijkstra算法
- `src/second_shortest_path/algorithms/spfa_extended.py` - SPFA算法
- `src/second_shortest_path/evaluation/visualizer.py` - 可视化工具
- `scripts/run_leetcode_experiments.py` - 实验脚本

## 实施步骤

### 1. 扩展 Dijkstra 算法的指标收集

**文件**: `src/second_shortest_path/algorithms/dijkstra_two_dist.py`

**需要添加的指标**:

- `_push_count`: Push操作次数（当前只有总的pq_operations）
- `_pop_count`: Pop操作次数
- `_d1_updates`: d1距离标签更新次数
- `_d2_updates`: d2距离标签更新次数

**修改位置**:

```python
# 在 __init__ 方法中添加新计数器（第45-48行附近）
self._push_count = 0
self._pop_count = 0
self._d1_updates = 0
self._d2_updates = 0

# 在 find_second_shortest 方法中：
# - 第89行：heappush 时增加 _push_count
# - 第96行：heappop 时增加 _pop_count

# 在 _relax_edge 方法中：
# - 第155-158行：更新d1时增加 _d1_updates
# - 第157行：更新d2时增加 _d2_updates
# - 第169行：更新d2时增加 _d2_updates
# - 第160-165行：push操作时增加 _push_count

# 在 get_statistics 方法中返回新指标（第173-186行）
```

### 2. 扩展 SPFA 算法的指标收集

**文件**: `src/second_shortest_path/algorithms/spfa_extended.py`

**需要添加的指标**:

- `_push_count`: 入队次数（重命名现有的enqueue_operations）
- `_pop_count`: 出队次数（重命名现有的dequeue_operations）
- `_d1_updates`: d1距离标签更新次数
- `_d2_updates`: d2距离标签更新次数

**修改位置**:

```python
# 在 __init__ 方法中添加新计数器（第45-49行附近）
self._push_count = 0  # 替代 _enqueue_operations
self._pop_count = 0   # 替代 _dequeue_operations
self._d1_updates = 0
self._d2_updates = 0

# 在 find_second_shortest 方法中：
# - 第96行：入队时增加 _push_count
# - 第103行：出队时增加 _pop_count

# 在 _relax_edge 方法中：
# - 第162-165行：更新d1时增加 _d1_updates
# - 第164行：更新d2时增加 _d2_updates
# - 第180行：更新d2时增加 _d2_updates
# - 第169-176行：入队操作时增加 _push_count
# - 第183-185行：入队操作时增加 _push_count

# 在 get_statistics 方法中返回新指标（第187-202行）
```

### 3. 重新实现可视化模块

**文件**: `src/second_shortest_path/evaluation/visualizer.py`

**需要重新实现/增强的方法**:

#### 3.1 `plot_runtime_comparison` (第34-70行)

- 改为箱线图，展示P50/P95/P99
- 添加统计信息标注

#### 3.2 `plot_scalability` (第72-109行)

- 保持折线图风格
- 确保按图规模（n或m）正确分组

#### 3.3 `plot_complexity_verification` (第111-157行) - **重点修改**

- 使用 `scipy.optimize.curve_fit` 进行完整的曲线拟合
- Dijkstra: 拟合 `T = c * M * log(N)`
- SPFA: 同时拟合 `T = c1 * M * log(N)` 和 `T = c2 * M * N`，选择R²更高的
- 在图表上显示拟合方程和R²值
- 添加理论复杂度曲线

#### 3.4 `plot_operations_comparison` (第159-213行) - **重点修改**

- 改为分组柱状图
- 展示：Push次数、Pop次数、边松弛次数
- 按图规模分组对比
- 添加理论值参考线（如Dijkstra的O(M)）

#### 3.5 `plot_percentile_comparison` (第215-254行)

- 增强箱线图
- 添加P50/P95/P99标注
- 添加均值点

#### 3.6 新增方法：`plot_distance_updates_comparison`

- 对比d1和d2的更新次数
- 分组柱状图
- 验证理论上限

### 4. 更新实验脚本

**文件**: `scripts/run_leetcode_experiments.py`

**修改位置**:

#### 4.1 数据收集部分（第110-178行）

```python
# 更新统计信息收集，添加新指标：
'dijkstra_push_count': d_stats.get('push_count', 0),
'dijkstra_pop_count': d_stats.get('pop_count', 0),
'dijkstra_d1_updates': d_stats.get('d1_updates', 0),
'dijkstra_d2_updates': d_stats.get('d2_updates', 0),

'spfa_push_count': s_stats.get('push_count', 0),
'spfa_pop_count': s_stats.get('pop_count', 0),
'spfa_d1_updates': s_stats.get('d1_updates', 0),
'spfa_d2_updates': s_stats.get('d2_updates', 0),
```

#### 4.2 可视化生成部分（第302-326行）

添加新的可视化调用：

```python
# 1. 复杂度验证图（重点）
Visualizer.plot_complexity_verification(viz_df, viz_dir / "complexity_verification.png")

# 2. 操作次数对比图（新增）
Visualizer.plot_operations_comparison(viz_df, viz_dir / "operations_comparison.png")

# 3. 距离更新对比图（新增）
Visualizer.plot_distance_updates_comparison(viz_df, viz_dir / "distance_updates.png")

# 保留现有的：
# - runtime_comparison
# - scalability
# - percentile_comparison
```

#### 4.3 报告生成部分（第264-295行）

在JSON报告中添加新指标的统计：

```python
'avg_push_count': float(df['dijkstra_push_count'].mean()),
'avg_pop_count': float(df['dijkstra_pop_count'].mean()),
'avg_d1_updates': float(df['dijkstra_d1_updates'].mean()),
'avg_d2_updates': float(df['dijkstra_d2_updates'].mean()),
```

### 5. 依赖检查

确保 `scipy` 已安装（用于曲线拟合）：

```python
# 在 visualizer.py 顶部添加
from scipy.optimize import curve_fit
from scipy import stats
```

## 实施顺序

1. **第一步**: 扩展算法类的指标收集（步骤1和2）
2. **第二步**: 重新实现可视化方法（步骤3）
3. **第三步**: 更新实验脚本（步骤4）
4. **第四步**: 运行测试验证所有图表正确生成

## 预期输出

完成后，运行 `scripts/run_leetcode_experiments.py` 将生成：

- `runtime_comparison.png` - 运行时间箱线图
- `scalability.png` - 可扩展性折线图
- `complexity_verification.png` - 复杂度验证散点图+拟合曲线
- `operations_comparison.png` - 操作次数分组柱状图
- `distance_updates.png` - 距离更新对比图
- `percentile_comparison.png` - 百分位数箱线图
- `leetcode_report.json` - 包含所有指标的详细报告
- `leetcode_results.csv` - 完整的测试结果表格

### To-dos

- [ ] 扩展 Dijkstra 算法的指标收集系统，添加 push_count, pop_count, d1_updates, d2_updates
- [ ] 扩展 SPFA 算法的指标收集系统，添加 push_count, pop_count, d1_updates, d2_updates
- [ ] 重新实现可视化模块的所有方法，包括完整的曲线拟合和新增图表类型
- [ ] 更新实验脚本以收集新指标并生成所有要求的可视化图表
- [ ] 运行完整实验并验证所有图表和报告正确生成