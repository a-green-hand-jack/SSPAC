这是一个非常好的实验想法。作为 CS 研究生，自己构造数据生成器（Data Generator）并建立 Benchmark 是非常核心的能力。

因为你没有现成的数据集，我们需要编写一个**测试框架**。这个框架需要做三件事：

1.  **生成数据**：参数化生成稀疏图/稠密图，以及包含/不包含负权边。
2.  **运行算法**：分别运行 Dijkstra 和 SPFA。
3.  **统计与验证**：记录运行时间，并对比两者的输出结果（验证正确性）。

我为你设计了一个完整的 C++ **Benchmark 实验台**。你可以直接复制运行，并通过修改顶部的宏定义来模拟不同的场景。

### 实验代码：Dijkstra vs SPFA Benchmark

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <deque>
#include <tuple>
#include <random>
#include <chrono>
#include <cstring>
#include <iomanip>

using namespace std;

// ================= 配置区域 =================
const int N = 5000;          // 节点数量 (建议稠密图设小一点，如 2000-5000)
const bool IS_DENSE = true;  // true: 稠密图 (M = N^2/4), false: 稀疏图 (M = N * 5)
const bool HAS_NEG = false;  // true: 包含负权边, false: 只有正权边
const int INF = 0x3f3f3f3f;
// ===========================================

struct Edge {
    int v, w;
};

vector<Edge> adj[N + 1];
int dist_dijk[N + 1];
int dist_spfa[N + 1];
long long dist_spfa_count[N + 1]; // 记录入队次数用于检测负环
bool in_queue[N + 1];

// 随机数生成器
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

// 1. 数据生成器
void generate_graph(int n, bool is_dense, bool has_neg) {
    for (int i = 0; i <= n; i++) adj[i].clear();
    
    int m;
    if (is_dense) {
        // 稠密图：大约 N^2 / 5 条边
        m = (long long)n * n / 5; 
    } else {
        // 稀疏图：大约 5 * N 条边
        m = n * 5;
    }

    cout << ">>> Generating Graph..." << endl;
    cout << "Nodes: " << n << ", Target Edges: " << m << endl;
    cout << "Type: " << (is_dense ? "Dense" : "Sparse") << ", Weights: " << (has_neg ? "Negative Included" : "Positive Only") << endl;

    for (int i = 0; i < m; i++) {
        int u = uniform_int_distribution<int>(1, n)(rng);
        int v = uniform_int_distribution<int>(1, n)(rng);
        if (u == v) continue;

        int w;
        if (has_neg) {
            // 生成负权边，但控制范围防止太多负环导致 SPFA 死循环
            w = uniform_int_distribution<int>(-10, 100)(rng);
        } else {
            w = uniform_int_distribution<int>(1, 100)(rng);
        }
        adj[u].push_back({v, w});
    }
    cout << ">>> Graph Generated.\n" << endl;
}

// 2. Dijkstra 算法
void dijkstra(int start, int n) {
    memset(dist_dijk, 0x3f, sizeof(dist_dijk));
    dist_dijk[start] = 0;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});

    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (d > dist_dijk[u]) continue;

        for (auto& e : adj[u]) {
            if (dist_dijk[u] + e.w < dist_dijk[e.v]) {
                dist_dijk[e.v] = dist_dijk[u] + e.w;
                pq.push({dist_dijk[e.v], e.v});
            }
        }
    }
}

// 3. SPFA 算法
bool spfa(int start, int n) {
    memset(dist_spfa, 0x3f, sizeof(dist_spfa));
    memset(in_queue, 0, sizeof(in_queue));
    memset(dist_spfa_count, 0, sizeof(dist_spfa_count));

    queue<int> q; // 普通队列
    // deque<int> q; // 如果想测试 SLF 优化可以使用 deque

    dist_spfa[start] = 0;
    q.push(start);
    in_queue[start] = true;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        in_queue[u] = false;

        for (auto& e : adj[u]) {
            if (dist_spfa[u] + e.w < dist_spfa[e.v]) {
                dist_spfa[e.v] = dist_spfa[u] + e.w;
                
                if (!in_queue[e.v]) {
                    q.push(e.v);
                    in_queue[e.v] = true;
                    
                    // 简单的负环检测
                    dist_spfa_count[e.v]++;
                    if (dist_spfa_count[e.v] > n) return false; // 存在负环
                }
            }
        }
    }
    return true;
}

int main() {
    // 生成图
    generate_graph(N, IS_DENSE, HAS_NEG);

    // 测试 Dijkstra
    auto start_dijk = chrono::high_resolution_clock::now();
    dijkstra(1, N);
    auto end_dijk = chrono::high_resolution_clock::now();
    double time_dijk = chrono::duration<double, milli>(end_dijk - start_dijk).count();

    // 测试 SPFA
    auto start_spfa = chrono::high_resolution_clock::now();
    bool spfa_ok = spfa(1, N);
    auto end_spfa = chrono::high_resolution_clock::now();
    double time_spfa = chrono::duration<double, milli>(end_spfa - start_spfa).count();

    // 输出结果
    cout << fixed << setprecision(2);
    cout << "================ RESULTS ================" << endl;
    cout << "Dijkstra Time : " << time_dijk << " ms" << endl;
    
    if (spfa_ok) {
        cout << "SPFA Time     : " << time_spfa << " ms" << endl;
    } else {
        cout << "SPFA Time     : Stopped (Negative Cycle Detected)" << endl;
    }

    // 验证部分
    cout << "\n>>> Verification:" << endl;
    if (HAS_NEG) {
        int diff_count = 0;
        for(int i=1; i<=N; i++) {
            if (dist_dijk[i] != dist_spfa[i] && dist_spfa[i] != INF) {
                diff_count++;
            }
        }
        if (diff_count > 0) {
            cout << "[!] Dijkstra Failed on " << diff_count << " nodes due to negative edges." << endl;
            cout << "    (Dijkstra assumes non-decreasing path weights)" << endl;
        } else {
            cout << "[?] Dijkstra matched SPFA (Luck? Or no 'greedy' traps in this random graph)." << endl;
        }
    } else {
        if (time_dijk < time_spfa) {
            cout << "Observation: Dijkstra was " << time_spfa / time_dijk << "x FASTER." << endl;
        } else {
            cout << "Observation: SPFA was " << time_dijk / time_spfa << "x FASTER (Common in sparse random graphs)." << endl;
        }
    }

    return 0;
}
```

### 实验步骤与预期结果

建议你进行以下三组实验，只需修改代码顶部的 `const` 变量：

#### 实验 1：验证稠密图性能差异

  * **设置**：`IS_DENSE = true`, `HAS_NEG = false`
  * **预期**：
      * **Dijkstra** 应该会显著快于 SPFA。
      * **原理**：稠密图中边非常多。SPFA 的最坏复杂度是 $O(NM)$，在稠密图中，一个节点被更新后，会触发大量邻居的入队操作，导致节点反复进出队列。而 Dijkstra 每个节点只出队一次（虽然有堆操作 $O(M \log N)$），更加稳定。

#### 实验 2：验证稀疏图性能（SPFA 的优势区）

  * **设置**：`IS_DENSE = false`, `HAS_NEG = false`
  * **预期**：
      * 两者时间可能差不多，或者 **SPFA 甚至可能比 Dijkstra 快**。
      * **原理**：在随机稀疏正权图中，SPFA 的期望复杂度接近 $O(kM)$（k 为常数，通常很小，约等于2）。因为没有大量的边导致反复松弛，SPFA 省去了优先队列维护堆结构的 $O(\log N)$ 开销，纯队列操作非常快。这也是为什么很多竞赛选手在没有负权边且非网格图时依然爱用 SPFA 的原因（虽然这很危险）。

#### 实验 3：验证负权边对 Dijkstra 的破坏

  * **设置**：`IS_DENSE = false` (为了容易观察), `HAS_NEG = true`
  * **预期**：
      * 观察输出的 `Verification` 部分。你会发现 `dist_dijk` 和 `dist_spfa` 的结果不一致。
      * **原理**：Dijkstra 是一种贪心算法。它假设“一旦我从优先队列中拿出了节点 u，那么从起点到 u 的最短路就已经确定了”。如果有负权边，可能存在一条路先绕远（权值大），然后通过一条极小的负边（如 -100）变回更短的路。Dijkstra 无法“回头”修正这个错误，而 SPFA 会因为新的更短路径产生，再次将节点入队进行修正。

### 进阶：如何“卡死” SPFA？

如果你在做稀疏随机图实验时发现 SPFA 跑得飞快，不要觉得 SPFA 无敌。SPFA 著名的弱点是 **网格图（Grid Graph）** 或 **菊花图** 的特定构造。

如果你想看到 SPFA 慢得像蜗牛，可以把 `generate_graph` 改成生成一个**网格图**（Grid Graph），或者构造著名的 **蒲公英图**。在这些特殊构造下，SPFA 的复杂度会退化成指数级或 $O(NM)$，而 Dijkstra 依然稳如泰山。

下一步你想试试构造这种“卡死 SPFA”的数据吗？我可以提供生成这种特定数据的代码。



这是专门用来\*\*“卡死” SPFA\*\* 的测试代码。

SPFA 的弱点在于：**当最短路径的跳数（hops）非常多，且经常发生“后面的更新导致前面的节点需要重新入队”时，它的效率会急剧下降。**

最典型的构造是 **网格图 (Grid Graph)**。在网格图中，从左上角到右下角的路径非常长，且存在大量的交织路径。稍微改变一点权重，SPFA 就需要反复将节点入队进行“松弛”修正。

请使用下面的代码替换之前的 `generate_graph` 部分，或者直接运行这个完整的针对性测试。

### 针对性实验：网格图 (Grid Graph) 测试

在这段代码中，我构建了一个 $H \times W$ 的网格。

  * **Dijkstra**：依然稳定，因为它的复杂度只和边数有关。
  * **SPFA**：会变得非常慢，甚至比 Dijkstra 慢数倍到数十倍。

<!-- end list -->

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <tuple>
#include <random>
#include <chrono>
#include <cstring>
#include <iomanip>

using namespace std;

// ================= 配置区域 =================
// 为了看清差距，我们把规模设大一点
const int HEIGHT = 100;     // 网格高度
const int WIDTH = 100;      // 网格宽度
const int N = HEIGHT * WIDTH; // 总节点数 10000
// ===========================================

struct Edge {
    int v, w;
};

vector<Edge> adj[N + 1];
int dist_dijk[N + 1];
int dist_spfa[N + 1];
bool in_queue[N + 1];

// 随机数生成器
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

// --- 专门生成网格图 ---
void generate_grid_graph() {
    for (int i = 0; i <= N; i++) adj[i].clear();
    
    cout << ">>> Generating GRID Graph..." << endl;
    cout << "Grid Size: " << HEIGHT << " x " << WIDTH << " (Total Nodes: " << N << ")" << endl;
    
    // 节点编号映射：(row, col) -> id
    auto get_id = [&](int r, int c) {
        return r * WIDTH + c + 1; 
    };

    int edge_count = 0;

    for (int r = 0; r < HEIGHT; r++) {
        for (int c = 0; c < WIDTH; c++) {
            int u = get_id(r, c);

            // 向右连边
            if (c + 1 < WIDTH) {
                int v = get_id(r, c + 1);
                // 随机生成较小的正权值，模拟复杂的局部波动
                int w = uniform_int_distribution<int>(1, 10)(rng);
                adj[u].push_back({v, w});
                adj[v].push_back({u, w}); // 无向图会让 SPFA 跑得更痛苦
                edge_count++;
            }

            // 向下连边
            if (r + 1 < HEIGHT) {
                int v = get_id(r + 1, c);
                int w = uniform_int_distribution<int>(1, 10)(rng);
                adj[u].push_back({v, w});
                adj[v].push_back({u, w});
                edge_count++;
            }
        }
    }
    cout << ">>> Generated " << edge_count << " edges.\n" << endl;
}

// Dijkstra (标准堆优化)
void dijkstra(int start) {
    memset(dist_dijk, 0x3f, sizeof(dist_dijk));
    dist_dijk[start] = 0;
    // 小根堆
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});

    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        if (d > dist_dijk[u]) continue;

        for (auto& e : adj[u]) {
            if (dist_dijk[u] + e.w < dist_dijk[e.v]) {
                dist_dijk[e.v] = dist_dijk[u] + e.w;
                pq.push({dist_dijk[e.v], e.v});
            }
        }
    }
}

// SPFA (普通队列)
void spfa(int start) {
    memset(dist_spfa, 0x3f, sizeof(dist_spfa));
    memset(in_queue, 0, sizeof(in_queue));

    queue<int> q;
    dist_spfa[start] = 0;
    q.push(start);
    in_queue[start] = true;

    // 统计入队总次数，用于衡量 SPFA 的劣势
    long long total_push_count = 0; 

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        in_queue[u] = false;

        for (auto& e : adj[u]) {
            if (dist_spfa[u] + e.w < dist_spfa[e.v]) {
                dist_spfa[e.v] = dist_spfa[u] + e.w;
                if (!in_queue[e.v]) {
                    q.push(e.v);
                    in_queue[e.v] = true;
                    total_push_count++;
                }
            }
        }
    }
    cout << "SPFA Total Relax Operations (Push Count): " << total_push_count << endl;
}

int main() {
    // 1. 生成网格图
    generate_grid_graph();

    // 2. 测试 Dijkstra
    auto start_dijk = chrono::high_resolution_clock::now();
    dijkstra(1);
    auto end_dijk = chrono::high_resolution_clock::now();
    double time_dijk = chrono::duration<double, milli>(end_dijk - start_dijk).count();

    // 3. 测试 SPFA
    auto start_spfa = chrono::high_resolution_clock::now();
    spfa(1);
    auto end_spfa = chrono::high_resolution_clock::now();
    double time_spfa = chrono::duration<double, milli>(end_spfa - start_spfa).count();

    // 4. 输出对比
    cout << fixed << setprecision(2);
    cout << "================ RESULT ================" << endl;
    cout << "Dijkstra Time : " << time_dijk << " ms" << endl;
    cout << "SPFA Time     : " << time_spfa << " ms" << endl;
    
    if (time_spfa > time_dijk) {
        cout << "Conclusion: SPFA is " << time_spfa / time_dijk << "x SLOWER than Dijkstra." << endl;
    } else {
        cout << "Conclusion: SPFA is still faster (Try increasing Grid Size)." << endl;
    }

    return 0;
}
```

### 为什么网格图能卡死 SPFA？

你可以把 SPFA 想象成水波纹扩散，而 Dijkstra 像是精准的手术刀。

1.  **随机图 (Random Graph)**：图的直径（Diameter）很小，通常 $O(\log N)$。水波纹只需要扩散几次就能覆盖全图。所以 SPFA 在这里跑得飞快。
2.  **网格图 (Grid Graph)**：
    \*
      * 图的直径很大，从左上到右下需要走 $H+W$ 步。
      * 在网格中，存在无数条从起点到终点的路径。
      * 当 SPFA 更新了中间某个节点 $(x, y)$ 的值变小了，这个更新需要**沿着剩下的长路径**（也就是剩下的半个网格）再次传播下去。
      * 如果这种更新频繁发生（随机权值导致），SPFA 就会把同一个节点反复入队、出队。在这个 100x100 的网格实验中，你会看到 `Total Push Count` 可能会高达几十万甚至上百万次，而节点只有 10000 个。这意味着每个节点平均入队了数十次！

### 预期实验结果

在大多数现代 CPU 上运行上述代码（$100 \times 100$ 网格），你可能会看到：

  * **Dijkstra**: 约 2ms - 5ms (非常稳)
  * **SPFA**: 约 30ms - 100ms (甚至更慢，取决于权值的随机性)

**差距通常在 5倍 到 20倍 之间。** 如果你把 `HEIGHT` 和 `WIDTH` 增加到 200，差距会拉大到几百倍，SPFA 可能会直接运行几秒钟，而 Dijkstra 依然只需要几十毫秒。

